@startuml Model 3

'les differentes cartes : 

'Cette classe rassemble les elements commun à chaques cartes 
abstract class Carte{
    - materiaux_construction_primaires : *RassourcePrimaire[4]
    - materiaux_construction_secondaires : *RessourceSecondaire[2]
    - cout_construction : unsigned int

    -position : unsigned int
    -accessible : bool
    -face_visible : bool
    
    +void set_position(unsigned int pos);
    +void set_materiaux_construction_primaire(RessourcePrimaire r); 
    +void set_materiaux_construction_secondaire(RessourceSecondaire r);
    +void set_accessible();
    +void set_face_visible(); 

    +unsigned int get_position() const;
    +unsigned int getPrix() const;
    +bool est_facevisible() const;
    +bool est_accessible() const;
    +RessourcePrimaire* getMateriauxPrimaires() const;
    +RessourceSecondaire* getMateriauxSecondaires() const;

    +virtual std::string get_type() const = 0;
}

'Notes : J'ai compté pour les listes 4 et 2 en longueurs suffisent
'Age est une enumeration

'La methode gettype renvoie le type de la carte ("Science", "Militaire", "Commerce"...)

'out met tous les arguments d'etat de la carte a None, (position, facevisible et accessible)





'-----------------------------LES AUTRES CARTES--------------------'
'Hérite tous de la classe carte carte

'Une Merveille est techniquement une carte
class Merveille{
    - capacite : *Capacite[3]
    - pt_victoire : unsigned int
    - production : *RessourceSecondaire[3]

    + const exec_capacite()
}
'Les Merveille Grand Phare et Piree peuvent produire une ressource

'Les autres types de cartes

'Cartes marrons 
class CarteRessourcePrimaire{
    - production : *RessourcePrimaire[2]

    +RessourcePrimaire* get_production() const;
    +void set_production(RessourcePrimaire r); 
    +std::string get_type() const override;
}

'Cartes gris
class CarteRessourceSecondaire{
    - production : RessourceSecondaire

    +RessourceSecondaire get_production() const;
    +string get_type() const override;
    +void set_production(RessourceSecondaire r);
}
'Pas de liste car produit toujours 1 seul ressource

'Cartes Jaunes
class CarteCommerce{
    - production_primaire : *RessourcePrimaire[2]
    - production_secondaire : *RessourceSecondaire[2]
    - capacite : Capacite
    - symbole_chainage : SymboleChainage
    - choix : boolean 
    - contrpartie : int 
    - pt_victoire : unsigned int

    +RessourcePrimaire* get_production_primaire() const;
    +RessourceSecondaire* get_production_second() const;
    +bool get_choix() const;
    +bool get_contrepatrie() const;
    +Capacite get_capacite() const;
    +unsigned int get_pt_victoire() const;
    +SymboleChainage get_symbole_chainage() const;

    +void set_symbole_chainage(SymboleChainage s);
    +void set_choix(bool c);
    +void set_contrepartie(bool c);
    +void set_pt_victoire(unsigned int n);
    +void set_capacite(Capacite c);
    +void set_production_primaire(RessourcePrimaire* pt);
    +void set_production_secondaire(RessourceSecondaire* pt);

    +string get_type() const override;
}
'Choix defini si la production doit etre choisi entre differentes ressources ou non
'Contrepartie defini si il faut "acheter" la ressource produite ou non, on notera 0 si ce n'est pas le cas

'exec_capacite() regarde l'attribut "capacite", et execute la fonction correspondante
'on rajoutera un méssage d'erreur si la capacite n'est pas possible

'Cartes Verts
class CarteScience{
    - symbole_science : SymboleScience
    - symbole_chainage : SymboleChainage
    - pt_victoire : unsigned int
    - capacite : Capacite::ajouter_symbole_science

    +unsigned int get_pt_victoire()const;
    +SymboleChainage get_symbole_chainage() const;
    +SymboleScience get_symbole_science() const;
    +Capacite get_capacite() const;

    +void set_symbole_chainage(SymboleChainage s);
    +void set_pt_victoire(unsigned int n);
    +void set_symbole_science(SymboleScience s);

    +get_type() const override;

}
'SymboleScience est une enumerations des symboles Science disponible dans le jeu
'SymboleChainage est une enumerations des symboles Science disponible dans le jeu

'Cartes Rouges
class CarteMilitaire{
    -unsigned int nb_symbole_militaire;
    -Capacite capacite = avance_militaire;
    -SymboleChainage symbole_chainage;


    +Capacite get_capacite() const;
    +unsigned int get_nb_symbole_militaire() const;
    +SymboleChainage get_symbole_chainage() const;

    +void set_nb_symbole_militaire(unsigned int nb);
    +void set_symbole_chainage(SymboleChainage s);

    +string get_type() const override;
}

'Cartes Bleu
class CartePrestige{
    - symbole_chainage : SymboleChainage
    - pt_victoire : unsigned int

    +unsigned int get_pt_victoire()const;
    +SymboleChainage get_symbole_chainage() const;
    +void set_symbole_chainage(SymboleChainage s);
    +void set_pt_victoire(unsigned int n);

    +string get_type() const override;
}

'Cartes Violets
class CarteGuilde{
    - effet_guilde : EffetGuilde

    +EffetGuilde get_effet_guilde();
    +void set_effet_guilde(EffetGuilde& effet);
    +void applique_effet_guilde(Joueur& joueur1, Joueur& joueur2);
    +string get_type() const override;

}
'EffetGuilde est un enumération defini après

'execEffetGuilde() effectue l'effet de guilde correspondant, a voir au niveau des arguments


CarteMilitaire --|> Carte
CarteCommerce --|> Carte
CarteScience --|> Carte
CartePrestige --|> Carte
Carte <|-- CarteGuilde
CarteRessourcePrimaire --|> Carte
CarteRessourceSecondaire --|> Carte
Merveille --|> Carte


'-----------------------------------------ATTENTION !!!-----------------------------------------------------'
'Tout elements se déclanchant qu'une seul fois, à la création de la carte est considéré comme une capacitée 
'Il existe une enumération capacité, définie plus loin

'---------------------------------------ENUMERATIONS LIE AUX CARTES-----------------------------------------'



'Permet de ne pas payer une carte si elle comporte le meme symbole qu'une carte déja construite par le joueur
enum SymboleChainage{
    none
    jarre 
    toneau
    masque 
    temple 
    soleil 
    goute 
    lune 
    pilier 
    cible 
    casque 
    feracheval 
    epee 
    tour 
    lyre 
    engrenage 
    livre 
    lampe 
}

SymboleChainage "*" -- "*" CartePrestige
SymboleChainage "*" -- "*" CarteMilitaire
SymboleChainage "*" -- "*" CarteScience
SymboleChainage "*" -- "*" CarteCommerce

'Symbole se trouvant sur les cartes sciences, 
'2 symbole similaire entraine la prise d'une jeton science pour le joueur, 
'6 symbole different entraine une victoire scientifique
enum SymboleScience{
    roue 
    plume 
    pilon 
    balance 
    globeterrestre 
    filaplomb
    bateau 
}

SymboleScience "*" -- "*" CarteScience

'Enumerations contenant les differents effets de Guilde (cartes violettes)
enum EffetGuilde{
    guilde_armateurs
    guilde_batisseurs
    guilde_commerçants
    guilde_magistrats
    guilde_tacticiens
    guilde_scientifiques
    guilde_usuriers
}
'Se referer à la fiche dans le docs pour les effets de chaques guides
EffetGuilde "*" - "*" CarteGuilde

'Les differentes capacité retrouvables sur certaines cartes, notement sur les cartes Merveille, militaire et de commerce
enum Capacite{
    none
    rejouer
    detruire_carte_marron
    detruire_carte_grise
    jouer_carte_defausse
    gagner_monnaie
    avancee_militaire
    choisir_jeton_science
    ajouter_symbole_science
}
'Je pense que les noms sont suffisement explicites, mais n'hésitez pas à poser des question si ce n'est pas clair

Capacite "*"  -- "*" CarteCommerce
Capacite "0..1"  -- "*" CarteMilitaire
Capacite "*"  -- "*" Merveille
Capacite "0..1" -- "*" CarteScience


'Les Ressources sont utilisé par les joureurs pour construir des batiments
'Elles sont produites par certaines cartes
enum RessourcePrimaire{
    none
    pierre
    bois
    brique
}

RessourcePrimaire  "*" -- "*" CarteRessourcePrimaire
RessourcePrimaire  "*" -- "*" CarteCommerce


enum RessourceSecondaire{
    none
    eau
    parchemin
}

RessourceSecondaire "*" -- "*" CarteRessourceSecondaire
RessourceSecondaire "*" -- "*" CarteCommerce
RessourceSecondaire "*" -- "*" Merveille



'-------------------------LES JETONS SCIENCES------------------------'
'Il sont au nombre de 10 avec des effets uniques

class JetonScience{
    - capacite_science : CapaciteScience

    +const exec_capacite_science()
    +CapaciteScience get_capacite_science() const
}
'CapaciteScience est une enumération des effets de chaques jetons, voir ci dessous

'Capacité déclanchées par les jetons sciences
enum CapaciteScience{
    none
    agriculture
    architecture
    economie
    loi
    maconnerie
    urbanisme
    theologie
    strategie
    philosophie
    mathematique
}
'Ce référer à la fiche pour les detailles de chaques capacitées
JetonScience "1" *-- "1" CapaciteScience

class JetonMalus{
    -malus : unsigned int 
    -position : unsigned int < Dim_plateau_militaire
    -joueur_cible : Joueur*

    +unsigned int get_positon()const;
    +unsigned int get_malus()const;
    +Joueur* get_joueur()const;
    +void exec_malus();

}

class PlateauMilitaire{
    -avance : unsigned int 
    -liste_jetons_malus : &JetonMalus[4]
    -joueur_derriere : &Joueur
    

    +void update_avance(unsigned int a, Joueur& joueur_cible);
    +void retirer_jeton_malus(JetonMalus& jeton);
    +JetonMalus& jeton_malus_ici() const;
}

PlateauMilitaire "1" *-- "4" JetonMalus
'Jdevant permet a la fois, en composant avec avance de savoir la position du jetons d'avancée miliaire
'Permet egalement de savoir directement quelle joueur est le moins avancé militairement, 
'ce qui permet de savoir quelles est le joueur qui doit commencer le nouvel age, ainsi que le joueur qui doit subir un malus

'updateavance(unsigned int, Joueur) permet d'avancer 
'le jeton d'un certain nombre de case en faveur du Joueur donnée en argument, (modifie avance et Jderiere si necessaire)

'retirer_jeton permet de retirer le jeton d'une case alors le joueur le moins avancé militairement subit un malus, 
'Utiliser la fonction appliquerCapacite de JetonMalus


'    - merveille_j1 : &Merveille[4]
'    - merveille_j2 : &Mervielle[4]
' il y'a une redondance ici parceque les merveilles construites appartiennent à la classe Joueur
'j'ai donc enlevé

class PlateauCarte{
    - age : unsigned int {1, 2, 3}
    - cartes_en_jeu : &Carte[20]
    - nb_merveilles_constr : unsigned int
    - defausses : &Cartes[60]

    + set_age(unsigned int)
    + const rend_accessible(&Carte)
    + const rend_face_visible(&Carte)
    + prendre(&Carte)
    + prendre(&Merveille)
    + defausser(&Carte)
    + const get_cartes_visibles() -> &Carte[]
    + const get_cartes_accessibles() -> &Carte[]
    + const nb_merveilles_restantes() -> unsigned int 
}

'set_age modifie l'age du plateau carte
'La methode rendaccessible(&Carte) permet de rendre FaceVisible et Accessible la carte Carte
'La methode prendre(&Carte) permet de supprimer la carte de la liste carte en Jeu
'La methode deffausser(&Carte) permet de mettre en defausse la carte et de la suprimmer de la liste des cartes en jeu
'getcartevisible() renvoie la liste des cartes faces visibles
'getcarteaccessible() renvoie la liste des cartes accessibles et donc face visible



'Le plateau Scientifique permet de gerer les jetons scientifique
class PlateauScience{
    -const int Dim_jetons_in_game = 5;
    -const int Dim_liste_position = 5;
    -const int Dim_jetons_out_game = 5;
    -JetonScience *jeton_in_game;
    -unsigned int *liste_position;
    -JetonScience *jeton_out_game;

    +JetonScience* tirer_jeton_out_game();
    +JetonScience* tirer_jeton_in_game(JetonScience& jeton);
    +void retirer_jeton_out_game(JetonScience& jeton);
    +void retirer_jeton_in_game(JetonScience& jeton);
    +void ajouter_jeton_in_game(JetonScience& jeton);
    +void ajouter_jeton_out_game(JetonScience& jeton);

}

PlateauScience  "1" *-- "5" JetonScience

'JetonInGame represente les jetons visibles et recupérables par les joueurs
'JetonsOutGame sont les jetons non tiré pour la partie, qui sont quand meme récuperables grace à des merveilles

'tirerjeton() tire 3 jeton aléatoirement dans jetonOUtGame, utilisé par la capacitée choisirjeton
'retirer jeton, retire le jeton ayant pour position Position de la liste jetonInGame


'/////////////IMPORTANT\\\\\\\\\\\\\\\
' Après réfléxion, je pense qu'il faut laisser les cartes et Merveilles crée dans les classes joueurs et non dans des plateaux appareant au joureurs 
'Car pour l'interface graphique ca ne change rien, et ce sera plus simple pour acceder au differents cout, sans avoir a aller chercher les cartes crées dans des plateau séparé de joueurs


'plateaumilitaire decrit l'avancé militaire d'un joueur vers le camps adverse, 
'nbmerveilles renseigne le nombre de merveilles déjà construites, pour rappel, on ne peut construire que 7 merveille dans une partie
Carte "*" --* "1" PlateauCarte
Joueur "2" -- "1" PlateauCarte
Joueur "2" -- "1" PlateauScience
Joueur "2" -- "1" PlateauMilitaire


'-------------------------------GESTION DU PLATEAU DE JEU------------------------


'Cette classe decrit l'etat du plateau de jeu à chaque instant
class Joueur{
    - carte_construite : &Carte[60]
    - merveille_construite : &Merveille[4]
    - jeton_construit : &JetonScience[6]
    - symboles_science: &SymboleScience[6]
    - monnaie : unsigned int
    - pt_victoire: unsigned int

    +Joueur() -> None
    +~Joueur() -> None

    + getMonnaie() -> unsigned int
    + getPtVcitoire() -> unsigned int
    + getNbCartesConstruites() -> int
    + getNbMerveillesConstruites() -> int
    + getNbJetonsScience() -> int
    + getNbSymbolesScience() -> int
    + getQuantiteDeRessourcePrimaire(const RessourcePrimaire&) -> int
    + getQuantiteDeRessourceSecondaire(const RessourceSecondaire& ) -> int
    + getCout(const Carte&) -> int

    + setMonnaie(unsigned int ) -> None
    + setPtVictoire(unsigned int ) -> None
    + gagnerArgent(unsigned int) -> None
    + gagnerPtVictoire(unsigned int) -> None

    + estConstructible(const Carte&, const PlateauCartes&) -> bool
    
    + construireCarte(Carte& , PlateauCartes& ) -> None
    + choisir_action(PlateauCartes& ) -> None


    + const est_constructible(const &Merveille, const &PlateauCarte) -> bool
    + construire_merveille(&Merveille, &Carte, &PlateauCarte) -> None
}
'60 car 20*3 = 60 le nombre de carte max qu'un joueur vera dans sa partie
'La fonction Verifie que la carte est accessible sur le Plateau (probablement via une méthode implémenté dans Plateau),
'Et effetue l'Action choisit par le joueur

'Si l'action choisit est construir ou merveille, alors le fonction vérifira que la carte ou la merveille est construissable puis l'ajoutera aux carte construites
'Si l'action chosit est de défausser la carte, la carte sera ajouté à la défausse du Plateau, et le joueur gagnera de la monnaie, 
'Dans tout les cas, la carte sera suprimé des cartes accésibles du plateau

'La méthode updatemonnaie permet d'ajouter ou retirer une quantité de monnaie donnée au joueur 

'La méthode getProduction() renvoie la production du joueur, pour cela elle interoge les cartes situées dans Carte

'La méthode getcout(Carte) renvoie le cout en monnaie, pour la construction de la carte Carte

'La méthode estconstructible(Carte) prend une carte en arguement Carte, et le joueur, car on fait Joueur.estconstructible(Carte)
'renvoie les cartes consturctible par le joueur, cad les cartes tel que Joueur.getcout(Carte) <= monnaie

'La fonction construire(Carte), ajoute Carte à carteconstruite et retire Joueur.getcout(Carte) à Joueur.monnaie 

'getptdevictoire() calcule le nombre de Pt de victoire du joueur, à executer en fin de partie

'Choisir action Carte, demande au joueur de Choisir une carte ACCESSIBLE, une fois la carte choisit elle est soit defaussé, soit construite, soit elle construit une merveille
Joueur "2" -- "*" Carte

@enduml
